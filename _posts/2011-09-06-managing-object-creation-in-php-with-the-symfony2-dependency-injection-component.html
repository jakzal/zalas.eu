---
layout: post
title: Managing object creation in PHP with the Symfony2 Dependency Injection component
tags:
- components
- DependencyInjection
- DIC
- php
- Symfony2
status: publish
type: post
published: true
meta:
  _edit_last: '1'
  description: Symfony's DependencyInjection component is a PHP implementation of
    a Service Container, also called Dependency Injection Container (DIC). The component
    also provides useful tools for handling service definitions, like XML loaders
    or dumpers.
  keywords: Symfony2,components,DIC,dependency,injection,container,service,DependencyInjection,php
---
Symfony's <a title="DependencyInjection Component" href="https://github.com/symfony/DependencyInjection">DependencyInjection component</a> is a PHP implementation of a <strong>Service Container</strong>, or as others like to call it, a <strong>Dependency Injection Container</strong> (DIC).

The component also provides useful tools for handling service definitions, like XML loaders or dumpers.
<p style="text-align: center;"><img class="aligncenter size-full wp-image-869" title="Dependency Injection" src="/uploads/wp/2011/09/injection.png" alt="" width="600" height="173" />image credits: <a href="http://www.flickr.com/photos/alexnormand/3132689510/">http://www.flickr.com/photos/alexnormand/3132689510/</a></p>
If you want to learn more about the dependency injection or the dependency injection container, read an excellent series of articles on the subject by Fabien Potencier: <a title="What is Dependency Injection?" href="http://fabien.potencier.org/article/11/what-is-dependency-injection">What is Dependency Injection?</a>

<strong>Note</strong>: Code used in this post is available on github: <a href="https://github.com/jakzal/SymfonyComponentsExamples">https://github.com/jakzal/SymfonyComponentsExamples</a>
<h2>Installation</h2>
Use the <a title="Symfony PEAR Channel" href="http://pear.symfony.com/">Symfony PEAR channel</a> or grab the source code <a title="Symfony2 DependencyInjection on github" href="https://github.com/symfony/Finder">directly from github</a>. For the purpose of this article we'll clone the component to the <em>vendor/</em> directory of the project.

We will also need Buzz, a lightweight HTTP client. It'll serve us as an example service. <a title="Symfony2 Config Component" href="https://github.com/symfony/Config/">Config</a> component is needed for one of the code snippets.
<pre>git clone https://github.com/symfony/DependencyInjection.git vendor/Symfony/Component/DependencyInjection
git clone https://github.com/symfony/Config.git vendor/Symfony/Component/Config
git clone https://github.com/symfony/ClassLoader.git vendor/Symfony/Component/ClassLoader
git clone https://github.com/kriswallsmith/Buzz.git vendor/Buzz</pre>
Symfony <em>ClassLoader</em> component will take care of the class autoloading (<em>read more about it in the</em> "<a title="Autoloading classes in an any PHP project with Symfony2 ClassLoader component" href="http://www.zalas.eu/autoloading-classes-in-any-php-project-with-symfony2-classloader-component">Autoloading classes in an any PHP project with Symfony2 ClassLoader component</a>").

Following code is sufficient to load classes from an any Symfony component (assuming components are put into the <em>vendor/Symfony/Component</em> directory):
<pre>&lt;?php
// src/autoload.php
require_once __DIR__.'/../vendor/Symfony/Component/ClassLoader/UniversalClassLoader.php';

$loader = new Symfony\Component\ClassLoader\UniversalClassLoader();
$loader-&gt;registerNamespaces(array(
    'Symfony' =&gt; __DIR__.'/../vendor',
    'Buzz'    =&gt; __DIR__.'/../vendor/Buzz/lib',
    'PSS'     =&gt; __DIR__
));
$loader-&gt;register();</pre>
<h2>Creating objects, the usual way</h2>
To create a <em>Browser</em> object and fetch content from google we could write the following piece of code:
<pre>$browser = new \Buzz\Browser();
$response = $browser-&gt;get('http://www.google.com');</pre>
By default <strong>Buzz</strong> uses <em>FileGetContents</em> as a client (which is a wrapper for <em>file_get_contents()</em> PHP function). Imagine new requirements came and forced us to use curl.

It's possible with Buzz. We just need to pass the client explicitly to the Browser:
<pre>$client = new \Buzz\Client\Curl();
$browser = new \Buzz\Browser($client);
$response = $browser-&gt;get('http://www.google.com');</pre>
After a while we noticed that our calls are often timed out. Default timeout of 5 seemed to be not sufficient so we increased it to 15:
<pre>$client = new \Buzz\Client\Curl();
$client-&gt;setTimeout(15);
$browser = new \Buzz\Browser($client);
$response = $browser-&gt;get('http://www.google.com');</pre>
Notice that code needs to be modified in all the places the <em>Browser</em> was used. It soon becomes a maintenance hell. Copy&amp;Paste is not the best way for re-usability ;) Just imagine effort needed to change the connection timeout when you create the browser in ten places. Or changing the client. What if you forget one?

We might create factory for the Browser. However, writing factories for all our services breaks <a title="DRY on Wikipedia" href="http://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY principle</a> as we end up writing classes with a similar purpose.

One of the solutions is to <strong>centralize the object creation</strong>. Dependency Injection Container (DIC) does just that.

<strong>Note</strong>: Dependency Injection Container is also called a <strong>Service Container</strong>. Thinking about objects managed by the container as services, better reflects the purpose of the container.
<h2>Creating objects with DIC</h2>
Instead of creating Browser object explicitly, we'll just <strong>tell the container how to do it</strong>:
<pre>&lt;?php
// dependencyinjection.php

require_once __DIR__.'/src/autoload.php';

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Definition;

$serviceContainer = new ContainerBuilder();

$browserDefinition = new Definition('Buzz\Browser');
$serviceContainer-&gt;setDefinition('browser', $browserDefinition);</pre>
And then <strong>ask it for the service</strong>:
<pre>$browser = $serviceContainer-&gt;get('browser');
$response = $browser-&gt;get('http://www.google.com/');</pre>
To replace the default HTTP client with Curl we might define another service and pass it to the browser as a reference:
<pre>&lt;?php
// dependencyinjection.php

// ...

$serviceContainer = new ContainerBuilder();

$clientDefinition = new Definition('Buzz\Client\Curl');
$clientDefinition-&gt;addMethodCall('setTimeout', array(15));
$serviceContainer-&gt;setDefinition('browser.client', $clientDefinition);

$browserDefinition = new Definition('Buzz\Browser', array(new Reference('browser.client')));
$serviceContainer-&gt;setDefinition('browser', $browserDefinition);</pre>
Notice that even though object creation becomes more and more complicated we <strong>manage it in one place</strong>.

On the other hand, every time we want to use a browser all we need to do is to get it from the container:
<pre>$browser = $serviceContainer-&gt;get('browser');</pre>
<strong>Service consumers are not affected by the service definition changes.</strong>

Another nice thing is that service won't be created unless we requested it.
<h2>Using XML to describe services</h2>
Services can be defined in many formats, not just PHP. <strong>Yaml</strong> and <strong>XML</strong> seem to be most convinient and readable ones. Symfony DependencyInjection component gives us tools to dump and load service definitions into the container with <em>ContainerBuilder</em>.

Moving service definitions to the configuration stored in Yaml or XML files has several advantages.

First of all we're creating even <strong>clearer separation</strong> between an object creation and the code which uses it.

Secondly, service definitions are more <strong>readable</strong>.

Following XML file describes the same services we defined in PHP before:
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;-- config/buzz.xml --&gt;
&lt;container xmlns="http://symfony.com/schema/dic/services"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd"&gt;
  &lt;services&gt;
    &lt;service id="browser.client" class="Buzz\Client\Curl"&gt;
      &lt;call method="setTimeout"&gt;
        &lt;argument&gt;15&lt;/argument&gt;
      &lt;/call&gt;
    &lt;/service&gt;
    &lt;service id="browser" class="Buzz\Browser"&gt;
      &lt;argument type="service" id="browser.client"/&gt;
    &lt;/service&gt;
  &lt;/services&gt;
&lt;/container&gt;</pre>
Loading the service definitions into the container is fairly simple. We need to create a <em>CotnainerBuilder</em> and pass it to an <em>XmlFileLoader</em> which will do all the work for us:
<pre>&lt;?php
// dependencyinjectionloader.php

require_once __DIR__.'/src/autoload.php';

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;
use Symfony\Component\Config\FileLocator;

/**
 * Loading services
 */

$serviceContainer = new ContainerBuilder();
$loader = new XmlFileLoader($serviceContainer, new FileLocator(__DIR__.'/config'));
$loader-&gt;load('buzz.xml');

/**
 * Using services
 */

$browser = $serviceContainer-&gt;get('browser');
$response = $browser-&gt;get('http://www.google.com/');</pre>
The opposite works equally well. To dump service definitions into an <em>XML</em> we need to pass <em>ContainerBuilder</em> instance to the <em>XmlDumper</em>:
<pre>&lt;?php
// dependencyinjection.php

// ...

use Symfony\Component\DependencyInjection\Dumper\XmlDumper;

$dumper = new XmlDumper($serviceContainer);
echo $dumper-&gt;dump();</pre>
<strong>Note</strong>: In a real life scenario we'd probably maintain our service definitions in XML or YML file(s) but dump them to PHP with <em>PhpDumper</em> for <strong>performance</strong> reasons.
<h2>Visualizing the services</h2>
In complex application services and relations between them might become, well... complex. GraphvizDumper might be handy in such situations as it lets us to present the services on a graph.
<pre>&lt;?php
// dependencyinjectiongraphviz.php

require_once __DIR__.'/src/autoload.php';

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Dumper\GraphvizDumper;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;
use Symfony\Component\Config\FileLocator;

$serviceContainer = new ContainerBuilder();
$loader = new XmlFileLoader($serviceContainer, new FileLocator(__DIR__.'/config'));
$loader-&gt;load('buzz.xml');

$dumper = new GraphvizDumper($serviceContainer);
echo $dumper-&gt;dump();</pre>
To actually generate a graph we will need a dot program (from graphviz). Once we dump the result of our script into a <em>services.dot</em> file we can easily convert it to an image:
<pre> dot -Tpng -o services.png services.dot</pre>
The result should look similar to the following picture.<a href="/uploads/wp/2011/08/services.png"><img class="aligncenter size-medium wp-image-847" title="Services" src="/uploads/wp/2011/08/services-400x112.png" alt="" width="400" height="112" /></a>
