---
layout: post
title: Doctrine2 and Symfony2
tags:
- doctrine2
- php
- Symfony2
status: publish
type: post
published: true
meta:
  _edit_last: '1'
  description: It's not a tutorial but a review of Doctrine2 basics. Object relational
    mapping with annotations and repository pattern are the two killer features of
    Doctrine2 I really like.
  keywords: Symfony2,Doctrine2,php,orm,annotations,repository,pattern
---
<img class="alignleft size-full wp-image-602" title="Symfony2 and Doctrine" src="/uploads/wp/2011/02/symfony2-doctrine-logos1.png" alt="Symfony2 and Doctrine" width="245" height="120" />I continue exploring the <a title="Symfony2" href="http://symfony-reloaded.org/">Symfony2 framework</a>. It's flexible enough to be used with any modern PHP ORM. However, as with everything in Symfony2, there are sensible defaults provided. In case of an ORM it's <a title="Doctrine Homepage" href="http://www.doctrine-project.org">Doctrine2</a> bundle.

One of the first things a newcomer wants to know about a new ORM is how to persist the data. The second is how to get it back.

<strong>Note</strong>: It's not a tutorial but a review of Doctrine2 basics. For tutorials visit <a title="Doctrine2 Tutorials" href="http://www.doctrine-project.org/docs/orm/2.0/en/#tutorials">Doctrine2 documentation</a> or <a title="Doctrine2 ORM in Symfony2" href="http://docs.symfony-reloaded.org/guides/doctrine/orm/index.html">Symfony2 ORM documentation</a>.
<h2>Persisting the data</h2>
In Doctrine1 we have a nice opportunity to define a model in an yml file called schema. Good news is we can still do it in Doctrine2.

But there's a better way.

What I really like about Doctrine2 is that we can persist object of <strong>any class</strong> by giving a <strong>mapping hints</strong> with <strong>annotations</strong>:
<pre>use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Entity
 * @ORM\Table(name="articles")
 */
class Article
{
    /**
     * @ORM\Id
     * @ORM\Column(type="integer")
     */
    private $id = null;

    /**
     * @ORM\Column(type="string", length="255")
     */
    private $title = null;

    /**
     * @ORM\Column(type="boolean", name="is_active")
     */
    private $isActive = false;
}</pre>
What's great about it is we only need to maintain one class instead of a class and its mapping in separate locations. No need to jump between files. Everything is in <strong>one place</strong>.

I couldn't think of a simpler solution.

Another great thing is we no longer need to extend a <strong>base record class</strong> just to be able to persist our data. Notice that Article class doesn't extend anything. It's an <strong>ordinary class</strong>.

It has quite some impact on <strong>performance</strong> as our objects are <strong>light</strong>. <em>Side effect is that while debugging we won't dump whole framework when passing a record to print_r() or var_dump(). </em>

So where's the old good <em>save()</em> method?

Doctrine2 doesn't follow active record pattern. Therefore there's no save, delete or other kind of methods typical to this pattern.

These responsibilities are given to the <strong>Entity Manager</strong>.

In Symfony2 Entity Manager can be retrieved from the <strong>Dependency Injection Container</strong>. Persisting the data in action might look like:
<pre>$article = new Article();
$article-&gt;setTitle('Doctrine2 in Symfony2');

$entityManager = $this-&gt;get('doctrine.orm.entity_manager');
$entityManager-&gt;persist($article);
$entityManager-&gt;flush();</pre>
I really like the fact that we work with <strong>POPO</strong>s (Plain Old PHP Objects). The class itself is free of code which persist its instance.
<h2>Get my data back!</h2>
Now that our data is stored in the database it'd be nice to retrieve it. Doctrine2 continues with an idea of <strong>DQL </strong>and <strong>finder methods</strong>:
<pre>$entityManager = $this-&gt;get('doctrine.orm.entity_manager');
$article = $entityManager-&gt;find('Article', $id);</pre>
Queries are run with the Entity Manager. It's important to know the Entity Manager proxies the call to the repository object. It works without any additional steps as the call is forwarded to a default implementation of a repository. Of course it can be changed.

As I don't like putting queries into the controller I was looking for the best place for them. The convention is to write a custom repository class for our entity (see <a title="Custom Repositories in Doctrine2" href="http://www.doctrine-project.org/docs/orm/2.0/en/reference/working-with-objects.html#custom-repositories">Custom Repositories</a> in Doctrine documentation):
<pre>class ArticleRepository extends EntityRepository
{
    public function getActiveArticles()
    {
        return $this-&gt;_em-&gt;createQuery('SELECT a FROM Article a WHERE a.isActive = ?', true)-&gt;getResult();
    }
}</pre>
In the entity class we need to tell Doctrine to use our repository instead of a generic one:
<pre>use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Entity(repositoryClass="ArticleRepository")
 * @ORM\Table(name="articles")
 */
class Article
{
  // ...
}</pre>
<h2>Where to go next?</h2>
I will continue exploring Doctrine2 while making progress with my Symfony2 project. There's a lot of interesting stuff left to learn: events, validators, inheritance to mention few. Also, there are many more annotations available than I used in the examples (like those describing <a title="Association mapping" href="http://www.doctrine-project.org/docs/orm/2.0/en/reference/association-mapping.html">associations</a>).
