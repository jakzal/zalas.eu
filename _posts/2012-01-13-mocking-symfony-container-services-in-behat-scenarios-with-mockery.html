---
layout: post
title: Mocking Symfony Container services in Behat scenarios with Mockery
tags:
- bdd
- behat
- DependencyInjection
- mockery
- Symfony2
status: publish
type: post
published: true
meta:
  _edit_last: '1'
  description: In functional tests it's a bit harder to mock services than in unit
    tests. We either don't have full control over objects being created or it's simply
    too laborious to mock half the framework. PSSMockeryBundle tries to solve thi
    sproblem in Behat and Symfony2.
  keywords: behat,bdd,mock,mockery,symfony
---
Mocking objects in unit tests is pretty straightforward as every object used in a test case is usually created in a scope of one test class. In functional tests it's a bit harder since we either don't have full control over objects being created or it's simply too laborious to mock half the framework.

Instead of functional tests I'm using <a title="Behat" href="http://behat.org/">Behat</a>. In the context of this blog post it satisfies the same need - <strong>verifies the external behavior</strong> of an application. It also brings similar problems.

<img class="aligncenter size-full wp-image-911" title="red-green" src="/uploads/wp/2012/01/red-green.png" alt="" width="600" height="183" />
<h2>The Problem</h2>
Let's pretend we have to implement a contact form on our website. Information submitted by user should be pushed to an external CRM system as a potential lead. Of course our CRM system has an API which makes the whole thing possible.

As BDD preaches we should start with a scenario:
<pre>Feature: Submitting contact form
  As a Visitor
  I want to contact sales department
  In order to receive detailed information on one of the products

  Scenario: Submitting the form
    When I go to "/contact-us"
     And I complete the contact form with following information
       |First name|Last name|Email                |
       |Jakub     |Zalas    |jzalas+spam@gmail.com|
     And CRM API is available
     And I submit the contact form
    Then a new lead should be sent to the CRM</pre>
In the controller, next to form handling, we also need code responsible for sending the lead to the CRM:
<pre>$crmClient = $this-&gt;get('crm.client');
$crmClient-&gt;sendLead($form-&gt;getData());</pre>
We're getting the service from a container and calling a method which should send a lead. The problem is we don't want to actually call an API while executing Behat scenarios. We would quickly end up with a CRM polluted with lots of fake data and scenarios failing ocasionaly when the API is not accessible.

It'd also be hard to set up a scene for a scenario (like simulating a timeout during http request).

The fact is we don't want to test the client of a CRM API (unit tests or <a title="PHPSpec" href="http://www.phpspec.net/">phpspec</a> will do a better job here). We just need to know if the service was called or to simulate a behavior.

That's what mocks were invented for.

<strong>We need to mock the service.</strong>
<h2>The Solution</h2>
I came up with a simple bundle that allows service mocking with <a title="Mockery on Github" href="https://github.com/padraic/mockery">Mockery</a>. It's called <a title="PSSMockeryBundle" href="https://github.com/PolishSymfonyCommunity/PSSMockeryBundle">PSSMockeryBundle</a> and you can download it from <a title="PSSMockeryBundle on Github" href="https://github.com/PolishSymfonyCommunity/PSSMockeryBundle">github</a>.

<strong>Note</strong>: PSSMockeryBundle works with Behat &lt;= 2.3. Use <a title="Symfony2MockerExtension for Behat" href="https://github.com/PolishSymfonyCommunity/Symfony2MockerExtension">Symfony2MockerExtension</a> with Behat &gt;= 2.4.

At the moment bundle provides <em>MockerContainer</em> and <em>MockerContainerContext</em>. <em>MockerContainer</em> is a container class which enables service mocking. <em>MockerContainerContext</em> is a Behat context with generic step for expectation verification and a handy <em>mockService()</em> method.

The step "<em>CRM API is available</em>" defines our expectations on the state of CRM service. It says that API should work properly and that's the situation we have to prepare:
<pre>/**
 * @Given /^CRM API is available$/
 *
 * @return null
 */
 public function crmApiIsAvailable()
 {
     $this-&gt;getMainContext()-&gt;getSubContext('container')
         -&gt;mockService('crm.client', 'PSS\Crm\Client')
         -&gt;shouldReceive('send')
         -&gt;once()
         -&gt;andReturn(true);
 }</pre>
<strong>Note</strong>: Container won't return the mock unless we first ask it to do so. In other words, it works as a regular container by default.

All the expectations are automatically checked after the scenario is executed (<em>@afterScenario</em> hook).

We can also do it manually which in some cases makes the scenario more readable:
<pre>/**
 * @Given /^(a )?new lead should be sent to (the )?CRM$/
 *
 * @return null
 */
 public function aNewLeadShouldBeSentToTheCrm()
 {
     return new Then(sprintf('the "%s" service should meet my expectations', 'crm.client'));
 }</pre>
<strong>Note</strong>: The "<em>the "&lt;serviceId&gt;" service should meet my expectations"</em> step is provided by <em>MockerContainerContext</em>.
<h2>Feedback much appreciated</h2>
This is my second attempt to solve this problem. It's much better than the first one (<em>don't even worth a mention</em>). I'm using this approach in my projects and it already proved to be working (at least so far). But <strong>I'd love to get your feedback</strong>.

Big thanks to <a title="Luis Cordova" href="http://www.craftitonline.com/">Luis Cordova</a> who exercised the <em>MockerContainerContext</em> in PHPSpec's WebSpec examples (<a title="PSSMockeryBundle + PHPSpec: The Automation Of Mocking Services Begins!" href="http://www.craftitonline.com/2012/01/pssmockerybundle-phpspec-the-automation-of-mocking-services-begins/">read his blog post</a>).
