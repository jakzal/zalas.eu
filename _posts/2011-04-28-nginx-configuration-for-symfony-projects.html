---
layout: post
title: Nginx configuration for Symfony projects
tags:
- configuration
- nginx
- php
- symfony
- Symfony2
status: publish
type: post
published: true
meta:
  _edit_last: '1'
  description: Recent release of Nginx 1.0.0 triggered me to refresh my knowledge
    about its configuration options. New variables and directives let me to simplify
    my configuration for Symfony projects (both 1.x and 2).
  keywords: nginx,php,symfony,Symfony2,configuration
---
<img class="alignright size-full wp-image-736" title="Nginx / Symfony" src="/uploads/wp/2011/04/nginx-symfony.png" alt="" width="350" height="90" />Recent release of Nginx 1.0.0 triggered me to refresh my knowledge about its configuration options. There were quite some additions since I looked in the docs for the last time. New variables and directives let me to simplify my configuration for Symfony projects (both 1.x and 2).

<strong>Warning:</strong> Configurations published on the Internet usually suffer from the vulnerability which allows to run a non-PHP file as a PHP. More about the problem here: "<a title="Setting up PHP-FastCGI and nginx? Don’t trust the tutorials: check your configuration!" href="https://nealpoole.com/blog/2011/04/setting-up-php-fastcgi-and-nginx-dont-trust-the-tutorials-check-your-configuration/">Setting up PHP-FastCGI and nginx? Don’t trust the tutorials: check your configuration!</a>". For Nginx+PHP installation read "<a title="Setting up a PHP development environment with Nginx on Ubuntu 11.04" href="http://www.zalas.eu/setting-up-a-php-development-environment-with-nginx-on-ubuntu-1104">Setting up a PHP development environment with Nginx on Ubuntu 11.04</a>".
<h2>Configuration</h2>
The convention says we should put virtual host configurations into <em>/etc/nginx/sites-available/</em> directory and then link to them in <em>/etc/nginx/sites-enabled/</em>.

Rules below define development virtual hosts. We'll put them into <em>/etc/nginx/sites-available/dev</em> file.
<pre>server {
    listen 80 default;
    server_name *.dev;

    root /var/www/$host/current/web;

    access_log /var/log/nginx/$host-access.log;
    error_log  /var/log/nginx/dev-error.log error;

    index app.php index.html index.htm;

    try_files $uri $uri/ @rewrite;

    location @rewrite {
        rewrite ^/(.*)$ /app.php/$1;
    }   

    location ~ \.php {
        # try_files $uri =404;

        fastcgi_index app.php;
        fastcgi_pass 127.0.0.1:9000;

        include fastcgi_params;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_param PATH_INFO $fastcgi_path_info;
        fastcgi_param PATH_TRANSLATED $document_root$fastcgi_path_info;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    }

    location ~ /\.ht {
        deny all;
    }
}</pre>
Don't forget about the symbolic link (<em>/etc/nginx/sites-enabled/dev</em>).
<h2>More about the configuration</h2>
<pre>    listen 80 default;</pre>
Nginx listens on the port 80 by default. What's important in this line is the second parameter - "default". It makes that Nginx treats given host as a default one.
<pre>    server_name *.dev;</pre>
Our dynamic virtual host will accept every <em>.dev</em> domain (<em>kuba.dev</em>, <em>myproject.dev</em> etc).

Alternatively we could simply list one ore more domains (i.e. <em>server_name zalas.eu</em>). In such case we'd probably define every domain in a separate <em>server {}</em> section.
<pre>    root /var/www/$host/current/web;</pre>
Root directory will be defined dynamically based on the <em>$host</em> variable (<em>/var/www/kuba.dev/current/web</em> for <em>kuba.dev</em> domain)<em>.</em>
<pre>    access_log /var/log/nginx/$host-access.log;
    error_log  /var/log/nginx/dev-error.log error;</pre>
Every domain will have its own access log. Unfortunately we cannot use <em>$host</em> variable with error logs. Therefore all the errors will be logged into the same file.
<pre>    index app.php index.html index.htm;</pre>
Index files are checked every time URL points to the directory. Nginx will try them one by one until it finds an existing one.

<em>app.php</em> is a default controller in Symfony2. For symfony 1.x it's usually <em>index.php</em>.
<pre>    try_files $uri $uri/ @rewrite;</pre>
It's a really elegant solution for readable URLs as it lets us to <a title="If is evil" href="http://wiki.nginx.org/IfIsEvil">avoid evil if statements</a>.

During the request Nginx will check for an existence of a file first. If the file doesn't exist it will look for a directory. If both checks fail it will rewrite the request to the <em>named location</em>.
<pre>    location @rewrite {
        rewrite ^/(.*)$ /app.php/$1;
    }</pre>
This named location is reached only if user wasn't requesting an existing file or directory. We want to rewrite such a request to the default controller.
<pre>    location ~ \.php {
        fastcgi_index app.php;
        fastcgi_pass 127.0.0.1:9000;

        include fastcgi_params;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_param PATH_INFO $fastcgi_path_info;
        fastcgi_param PATH_TRANSLATED $document_root$fastcgi_path_info;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    }</pre>
All the PHP requests will be routed to the fastcgi deamon (running locally on port 9000).

Appart from including default fastcgi parameters we make sure that PATH_INFO and SCRIPT_FILENAME variables are set properly. <em>fastcgi_split_path_info</em> says how to split the controller file from the path.
<pre>    location ~ /\.ht {
        deny all;
    }</pre>
This will forbid access to apache's <em>.htaccess</em> files. These are only simple text files for Nginx and we don't want them to be accessible via the browser.

&nbsp;
