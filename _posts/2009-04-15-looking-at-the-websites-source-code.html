---
layout: post
title: Looking at the website's source code
tags:
- cache
- filter
- html
- symfony
status: publish
type: post
published: true
meta:
  _edit_last: '1'
  keywords: source,code,html,look,cache,symfony,filter
  description: Most of the web programmers have some kind of deviation that tells
    them to look into the source code of the websites they visit. In many cases author
    planned to have nice indented output. In other cases author just didn't care.
---
Most of the web programmers have some kind of deviation that tells them to look into the source code of the websites they visit. In many cases author planned to have nice indented output. In other cases author just didn't care.

Usually templates are designed to produce output like:
<pre>&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;My great website&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div&gt;
      &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
but most often what's generated looks more like:
<pre>&lt;html&gt;  &lt;head&gt;
            &lt;title&gt;My great website&lt;/title&gt;  &lt;/head&gt;
    &lt;body&gt;
 &lt;div&gt;
      &lt;h1&gt;Hello!&lt;/h1&gt;    &lt;/div&gt;  &lt;/body&gt;
             &lt;/html&gt;</pre>
Tools like Opera's <a title="Opera Dragonfly" href="http://www.opera.com/dragonfly/">Dragonfly</a> or <a title="Firebug" href="http://getfirebug.com/">Firebug</a> for Firefox can help us to view the source in nice way. Html indentation matters only in the templates so designers and programmers can read it easily while developments. For browser or crawler it doesn't matter. Everything could be placed in one long line of code. Whitespace characters are just empty data which needs to go between the server and user's browser. The bigger is the website the more whitespace characters needs to be transfered and it's not even displayed. Maybe it's not such a big deal one could say. But it's also not such a big job to remove it...
<pre>&lt;html&gt;&lt;head&gt;&lt;title&gt;My great website&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;h1&gt;Hello!&lt;/h1&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</pre>
Symfony processes request in a <a title="Filters in symfony documentation" href="http://www.symfony-project.org/book/1_2/06-Inside-the-Controller-Layer#chapter_06_filters">filter chain</a>. I will show how to write a filter which removes all the whitespace characters (omitting pre-formated text of course). I called the class <em>zContentCleanerFilter</em>.

Let's start with main filter method - <em>execute()</em>. In this method first we'll execute next filter in the chain to let all the content be generated. If it's the first call of the filter and cleaning is turned on (<em>app_content_cleaner_enabled configuration </em>option is set to true) we invoke the cleaning method on the content (<em>zContentCleanerFilter::cleanContent()</em>) and overwrite it in the response object.
<pre>class zContentCleanerFilter extends sfFilter
{
  public function execute($filterChain)
  {
    $filterChain-&gt;execute();

    if ($this-&gt;isFirstCall() &amp;&amp; sfConfig::get('app_content_cleaner_enabled', false))
    {
      $response = $this-&gt;getContext()-&gt;getResponse();
      $content  = $response-&gt;getContent();
      $content  = self::cleanContent($content);

      $response-&gt;setContent($content);
    }
  }
}</pre>
<em>zContentCleanerFilter::cleanContent()</em> method uses callback function to process content line by line.
<pre>  public static function cleanContent($content)
  {
    return preg_replace_callback(
      '/^((\s*)(.*?)(\s*)(\r\n|\r|\n)|(\s*))/smi',
      array('zContentCleanerFilter', 'cleanLine'),
      $content
    );
  }</pre>
We have to check each line for preformatted text. If part of html code is inside &lt;<em>pre&gt;</em> tag than <em>zContentCleanerFilter::cleanLine()</em> returns it as is.
<pre>  private static function cleanLine($matches)
  {
    static $preCount = 0;

    $line = $matches[0];

    $startPreCount = substr_count($line, '&lt;pre');
    $endPreCount   = substr_count($line, '&lt;/pre&gt;');

    $preCount+= $startPreCount;
    $preCount-= $endPreCount;

    if ($preCount !== 0)
    {
      if (false !== strpos($line, '&lt;pre') &amp;&amp; $startPreCount !== $endPreCount)
      {
        // Preformatted code is starting, remove only white-spaces from the beginning
        $line = ltrim($line);
      }
    }
    elseif (false !== strpos($line, '&lt;/pre') &amp;&amp; $startPreCount !== $endPreCount)
    {
      // Preformatted code is ending, remove only trailing white-spaces
      $line = rtrim($line);
    }
    else
    {
      $line = trim($line);
    }

    return $line;
  }</pre>
That's all. To use the filter in a project we have to configure it to be run in the filter chain. I've added it into application's &lt;em&gt;factories.yml&lt;/em&gt; file after the cache filter.
<pre>rendering: ~
security:  ~
cache:     ~

# it's here to cache result when page is cached with layout
contentCleaner:
  class: zContentCleanerFilter

common: ~
execution: ~</pre>
Running content cleaning filter after cache filter takes advantage of caching the result of cleaning (which could be taken as not efficient). Cache filter is invoked sooner and skips filters which should be run afterwards.
